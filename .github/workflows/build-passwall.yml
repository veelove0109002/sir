name: Build PassWall for iStoreOS

# 修复版本：2025-08-30 20:45，解决安装过程中丢失登录状态问题

on:
  workflow_dispatch:
    inputs:
      target_arch:
        description: '目标架构'
        required: true
        default: 'x86_64'
        type: choice
        options:
          - x86_64
          - aarch64_cortex-a53
          - aarch64_generic
      sdk_version:
        description: 'SDK 版本标记（用于文件名和标签）'
        required: true
        default: '22.03.7'
      openssl_tag:
        description: 'OpenSSL 标记（用于标签）'
        required: true
        default: 'libopenssl_1.1'
      build_option:
        description: '构建选项'
        required: true
        default: 'standard'
        type: choice
        options:
          - minimal
          - standard
          - full

permissions:
  contents: write

jobs:
  build:
    name: 构建 PassWall 安装包
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 获取日期
        id: date
        run: echo "date=$(date)" >> "$GITHUB_OUTPUT"

      - name: 准备环境
        run: |
          sudo apt-get update
          sudo apt-get install -y makeself unzip curl jq
          rm -rf artifact/installer
          mkdir -p passwall-ipk artifact/installer staging

      - name: 下载 PassWall 包并解析版本
        id: fetch
        run: |
          set -e
          curl_gh() { curl -fsSL -H "Authorization: Bearer ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" "$@"; }
          # 架构映射
          case "${{ inputs.target_arch }}" in
            x86_64) ARCH_MAP="x86_64" ;;
            aarch64_cortex-a53) ARCH_MAP="aarch64_cortex-a53" ;;
            *) ARCH_MAP="aarch64_generic" ;;
          esac
          echo "ARCH_MAP=$ARCH_MAP" >> "$GITHUB_ENV"

          # 最新 tag
          API_LATEST="https://api.github.com/repos/xiaorouji/openwrt-passwall/releases/latest"
          LATEST_VERSION=$(curl_gh "$API_LATEST" | jq -r .tag_name || true)
          [ -z "$LATEST_VERSION" ] || [ "$LATEST_VERSION" = "null" ] && LATEST_VERSION="25.8.26-1"
          echo "LATEST_VERSION=$LATEST_VERSION" >> "$GITHUB_ENV"
          echo "version=$LATEST_VERSION" >> "$GITHUB_OUTPUT"

          # 下载压缩包（优先架构专属，其次通用）
          set +e
          URL1="https://github.com/xiaorouji/openwrt-passwall/releases/download/$LATEST_VERSION/passwall_packages_ipk_${ARCH_MAP}.zip"
          URL2="https://github.com/xiaorouji/openwrt-passwall/releases/download/$LATEST_VERSION/passwall_packages_ipk.zip"
          echo "尝试下载: $URL1"
          curl -fL "$URL1" -o passwall-ipk/passwall_packages.zip || curl -fL "$URL2" -o passwall-ipk/passwall_packages.zip
          RC=$?
          set -e
          if [ $RC -ne 0 ] || [ ! -s passwall-ipk/passwall_packages.zip ]; then
            echo "下载失败: 未找到可用的 PassWall 包"
            exit 1
          fi

          echo "下载成功，解压中..."
          unzip -o passwall-ipk/passwall_packages.zip -d passwall-ipk/
          rm -f passwall-ipk/passwall_packages.zip

          echo "已解压文件："
          ls -lh passwall-ipk | sed -n '1,200p'

      - name: 校验并定位 luci 顶层包（缺失则多源补齐）
        id: locate
        run: |
          set -e
          curl_gh() { curl -fsSL -H "Authorization: Bearer ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" "$@"; }
          LATEST_VERSION="${LATEST_VERSION:?need version}"

          # 放宽匹配：不再限定 _all.ipk
          find_app() { find passwall-ipk -type f -name '*luci-app-passwall*.ipk' | head -n1 || true; }
          find_i18n() { find passwall-ipk -type f -name '*luci-i18n-passwall-zh-cn*.ipk' | head -n1 || true; }

          APP_PKG="$(find_app)"; I18N_PKG="$(find_i18n)"

          fetch_from_release() {
            repo="$1"; tag="$2"
            if [ "$tag" = "latest" ]; then
              json="$(curl_gh "https://api.github.com/repos/$repo/releases/latest" || true)"
            else
              json="$(curl_gh "https://api.github.com/repos/$repo/releases/tags/$tag" || true)"
              [ -z "$json" ] && json="$(curl_gh "https://api.github.com/repos/$repo/releases/latest" || true)"
            fi
            [ -z "$json" ] && return 0
            if [ -z "$APP_PKG" ]; then
              # 放宽正则：任意前缀，任意后缀
              url="$(echo "$json" | jq -r '.assets[] | select(.name|test(".*luci-app-passwall.*\\.ipk$")) | .browser_download_url' | head -n1)"
              [ -n "$url" ] && [ "$url" != "null" ] && echo "下载 APP: $url (from $repo/$tag)" && curl -fL "$url" -o "passwall-ipk/$(basename "$url")" && APP_PKG="$(find_app)"
            fi
            if [ -z "$I18N_PKG" ]; then
              # 放宽正则：任意前缀，任意后缀
              url="$(echo "$json" | jq -r '.assets[] | select(.name|test(".*luci-i18n-passwall-zh-cn.*\\.ipk$")) | .browser_download_url' | head -n1)"
              [ -n "$url" ] && [ "$url" != "null" ] && echo "下载 I18N: $url (from $repo/$tag)" && curl -fL "$url" -o "passwall-ipk/$(basename "$url")" && I18N_PKG="$(find_i18n)"
            fi
          }

          # 若缺失则多源补齐
          if [ -z "$APP_PKG" ] || [ -z "$I18N_PKG" ]; then
            fetch_from_release "xiaorouji/openwrt-passwall" "$LATEST_VERSION"
            fetch_from_release "xiaorouji/openwrt-passwall" "latest"
            fetch_from_release "xiaorouji/openwrt-passwall-luci" "$LATEST_VERSION"
            fetch_from_release "xiaorouji/openwrt-passwall-luci" "latest"
          fi

          # 重新定位
          APP_PKG="$(find_app)"; I18N_PKG="$(find_i18n)"

          if [ -z "$APP_PKG" ]; then
            echo "未找到 luci-app-passwall 顶层包"
            find passwall-ipk -maxdepth 2 -type f -name '*.ipk' -print
            exit 1
          fi
          if [ -z "$I18N_PKG" ]; then
            echo "未找到 zh-cn 语言包"
            find passwall-ipk -maxdepth 2 -type f -name '*.ipk' -print
            exit 1
          fi

          echo "APP_PKG_PATH=$APP_PKG" >> "$GITHUB_ENV"
          echo "I18N_PKG_PATH=$I18N_PKG" >> "$GITHUB_ENV"
          echo "app_path=$APP_PKG" >> "$GITHUB_OUTPUT"
          echo "i18n_path=$I18N_PKG" >> "$GITHUB_OUTPUT"

          echo "定位结果："
          ls -lh "$APP_PKG" "$I18N_PKG"

      - name: 解析 luci-app-passwall 版本号（用于命名）
        id: parsever
        run: |
          set -e
          APP_PATH="${APP_PKG_PATH:-${{ steps.locate.outputs.app_path }}}"
          if [ -n "$APP_PATH" ]; then
            BASE="$(basename "$APP_PATH")"
            # 放宽正则：从任意前缀中提取 luci-app-passwall_XXX 的 XXX
            APPVER="$(echo "$BASE" | sed -E 's/^.*luci-app-passwall_([^_]+).*\.ipk$/\1/')"
          fi
          if [ -z "${APPVER:-}" ] || [ "$APPVER" = "$BASE" ]; then
            LV="${{ steps.fetch.outputs.version }}"; APPVER="${LV%%-*}"
          fi
          echo "appver=$APPVER" >> "$GITHUB_OUTPUT"
          echo "APP_VERSION=$APPVER" >> "$GITHUB_ENV"

      - name: 构建 Makeself 安装包（完全对齐样例结构/逻辑）
        run: |
          set -e
          ARCH_MAP="${ARCH_MAP:-${{ inputs.target_arch }}}"
          LATEST_VERSION="${LATEST_VERSION:-${{ steps.fetch.outputs.version }}}"
          APP_VERSION="${APP_VERSION:-${{ steps.parsever.outputs.appver }}}"
          SDK_VERSION="${{ inputs.sdk_version }}"
          OPENSSL_TAG="${{ inputs.openssl_tag }}"
          APP_PKG_PATH="${APP_PKG_PATH:-${{ steps.locate.outputs.app_path }}}"
          I18N_PKG_PATH="${I18N_PKG_PATH:-${{ steps.locate.outputs.i18n_path }}}"

          echo "将打包的顶层包："
          ls -lh "$APP_PKG_PATH" "$I18N_PKG_PATH"

          STAGING_ROOT="staging"
          STAGING_DIR="$STAGING_ROOT/$ARCH_MAP"
          DEP_DIR="$STAGING_DIR/depends"
          rm -rf "$STAGING_DIR"
          mkdir -p "$DEP_DIR"

          # 复制为固定文件名，避免通配匹配
          APP_BASE="$(basename "$APP_PKG_PATH")"
          I18N_BASE="$(basename "$I18N_PKG_PATH")"
          cp -f "$APP_PKG_PATH" "$STAGING_DIR/$APP_BASE"
          cp -f "$APP_PKG_PATH" "$STAGING_DIR/luci-app-passwall.ipk"  # 固定名称
          cp -f "$I18N_PKG_PATH" "$STAGING_DIR/$I18N_BASE"
          cp -f "$I18N_PKG_PATH" "$STAGING_DIR/luci-i18n-passwall-zh-cn.ipk"  # 固定名称

          # 其余 ipk 全部放入 depends
          while IFS= read -r -d '' f; do
            b="$(basename "$f")"
            if [ "$b" != "$APP_BASE" ] && [ "$b" != "$I18N_BASE" ]; then
              cp -f "$f" "$DEP_DIR/$b"
            fi
          done < <(find passwall-ipk -type f -name '*.ipk' -print0)

          echo "打包目录预览："
          find "$STAGING_DIR" -maxdepth 2 -type f -print | sed -n '1,200p'

          # 生成安装脚本（使用固定文件名，不再通配）
          cat > "$STAGING_DIR/install.sh" <<'EOF'
          #!/bin/sh
          set -e

          # 检查并安装 PassWall 必需依赖
          check_passwall_deps() {
            echo "检查 PassWall 必需依赖..."
            
            # iptables 透明代理模块
            local iptables_deps="iptables-mod-tproxy iptables-mod-socket iptables-mod-iprange iptables-mod-conntrack-extra"
            local kernel_deps="kmod-ipt-tproxy kmod-ipt-socket kmod-ipt-iprange kmod-ipt-conntrack-extra"
            
            for dep in $iptables_deps $kernel_deps; do
              if ! opkg list-installed | grep -q "^$dep "; then
                echo "安装缺失依赖: $dep"
                opkg install "$dep" 2>/dev/null || echo "警告: 无法安装 $dep，可能需要手动处理"
              fi
            done
            
            # 其他常用依赖
            local other_deps="ip-full ipset iptables-mod-extra iptables-mod-filter"
            for dep in $other_deps; do
              if ! opkg list-installed | grep -q "^$dep "; then
                echo "安装推荐依赖: $dep"
                opkg install "$dep" 2>/dev/null || true
              fi
            done
          }

          # 温和地刷新 LuCI 缓存（不重启服务，避免丢失登录状态）
          refresh_luci() {
            # 清理缓存文件
            rm -f /tmp/luci-indexcache 2>/dev/null || true
            rm -rf /tmp/luci-modulecache/* 2>/dev/null || true
            
            # 优先使用 luci-reload（如果可用）
            if command -v luci-reload >/dev/null 2>&1; then
              echo "使用 luci-reload 刷新 LuCI..."
              luci-reload 2>/dev/null || true
            else
              # 使用 Lua 直接重建索引（兼容不同版本函数名）
              if command -v lua >/dev/null 2>&1; then
                echo "使用 Lua 重建 LuCI 索引..."
                lua -e 'local ok,d=pcall(require,"luci.dispatcher"); if ok and d then if d.rebuild_index then d.rebuild_index() elseif d.createindex then d.createindex() end end' 2>/dev/null || true
              fi
              
              # 温和地重载 HTTP 服务（不重启）
              if [ -x /etc/init.d/uhttpd ]; then
                echo "重载 uhttpd..."
                /etc/init.d/uhttpd reload 2>/dev/null || true
              fi
              if [ -x /etc/init.d/nginx ]; then
                echo "重载 nginx..."
                /etc/init.d/nginx reload 2>/dev/null || true
              fi
            fi
            
            # 确保文件系统同步
            sync
          }

          # 使用固定文件名，不再通配
          APP_PKG="luci-app-passwall.ipk"
          I18N_PKG="luci-i18n-passwall-zh-cn.ipk"

          if [ ! -f "$APP_PKG" ]; then
            echo "错误: 缺少 $APP_PKG"
            ls -l
            exit 1
          fi

          # 安装前轻度刷新
          refresh_luci

          if ! opkg update; then
            echo "更新软件源列表错误，请检查路由器网络以及软件源。"
            exit 1
          fi

          # 安装基础依赖（容错）
          echo "安装基础依赖..."
          opkg install luci-compat luci-lib-jsonc libuci-lua 2>/dev/null || true

          # 检查并安装 PassWall 必需依赖
          check_passwall_deps

          # 安装 depends 下的 ipk（若存在）
          if [ -d depends ] && ls depends/*.ipk >/dev/null 2>&1; then
            echo "安装依赖包..."
            opkg install depends/*.ipk || true
          fi

          # 额外常用组件（容错）
          echo "安装额外组件..."
          opkg install haproxy shadowsocks-libev-ss-local shadowsocks-libev-ss-redir shadowsocks-libev-ss-server 2>/dev/null || true

          # 始终强制重装，避免版本判断带来的不确定性
          echo "安装 PassWall 主程序..."
          opkg install "$APP_PKG" --force-reinstall || exit 1

          # 安装中文语言包（仅本地文件）
          if [ -f "$I18N_PKG" ]; then
            echo "安装中文语言包: $I18N_PKG"
            opkg install "$I18N_PKG" || true
          else
            echo "未发现本地中文语言包，跳过安装"
          fi

          # 启用并启动服务
          if [ -x /etc/init.d/passwall ]; then
            echo "启用 PassWall 服务..."
            /etc/init.d/passwall enable 2>/dev/null || true
            /etc/init.d/passwall start 2>/dev/null || true
          fi
          
          # 重载防火墙（不重启）
          if [ -x /etc/init.d/firewall ]; then
            echo "重载防火墙规则..."
            /etc/init.d/firewall reload 2>/dev/null || true
          fi

          # 安装后轻度刷新
          refresh_luci

          # 验证依赖安装情况
          echo "验证关键依赖..."
          missing_deps=""
          for dep in iptables-mod-tproxy iptables-mod-socket iptables-mod-iprange; do
            if ! opkg list-installed | grep -q "^$dep "; then
              missing_deps="$missing_deps $dep"
            fi
          done
          
          if [ -n "$missing_deps" ]; then
            echo "警告: 以下依赖未安装，可能影响透明代理功能:$missing_deps"
            echo "请手动执行: opkg install$missing_deps"
          fi

          # 验证安装结果
          if [ -f /usr/lib/lua/luci/controller/passwall.lua ] || ls /usr/lib/lua/luci/controller/passwall/*.lua >/dev/null 2>&1; then
            echo "✓ 安装完成！请在 LuCI 界面 服务→PassWall 查看。"
            echo "  如果菜单未显示，请刷新浏览器或重新登录 LuCI。"
            if [ -z "$missing_deps" ]; then
              echo "  所有必需依赖已正确安装。"
            fi
            exit 0
          else
            echo "! 警告：未检测到 PassWall 控制器文件，可能需刷新浏览器或重新登录 LuCI。"
            exit 0
          fi
          EOF
          chmod +x "$STAGING_DIR/install.sh"

          OUTPUT="PassWall_${APP_VERSION}_${ARCH_MAP}_all_sdk_${SDK_VERSION}.run"
          LABEL="PassWall_${APP_VERSION}_with_sdk_${SDK_VERSION}_${OPENSSL_TAG}"
          makeself --gzip --nox11 "$STAGING_DIR" "$OUTPUT" "$LABEL" ./install.sh

          echo "PassWall(luci-app)版本: $APP_VERSION" > version.txt
          echo "上游Release Tag: $LATEST_VERSION" >> version.txt
          echo "SDK版本: $SDK_VERSION" >> version.txt
          echo "OpenSSL标记: $OPENSSL_TAG" >> version.txt
          echo "构建时间: ${{ steps.date.outputs.date }}" >> version.txt
          echo "目标架构: ${{ inputs.target_arch }}" >> version.txt
          echo "GitHub Actions运行ID: ${{ github.run_id }}" >> version.txt
          echo "构建选项: ${{ inputs.build_option }}" >> version.txt

          rm -rf artifact/installer/*
          mv -f "$OUTPUT" artifact/installer/
          mv -f version.txt artifact/installer/
          echo "构建产物："
          ls -lh artifact/installer/

      - name: 上传安装程序
        uses: actions/upload-artifact@v4
        with:
          name: PassWall_${{ steps.parsever.outputs.appver }}_${{ inputs.target_arch }}_all_sdk_${{ inputs.sdk_version }}
          path: ./artifact/installer/

      - name: 创建发布
        uses: softprops/action-gh-release@v1
        with:
          tag_name: passwall-${{ inputs.target_arch }}-${{ steps.parsever.outputs.appver }}-${{ github.run_id }}
          name: PassWall ${{ steps.parsever.outputs.appver }} for iStoreOS (${{ inputs.target_arch }})
          files: |
            artifact/installer/PassWall_${{ steps.parsever.outputs.appver }}_${{ inputs.target_arch }}_all_sdk_${{ inputs.sdk_version }}.run
            artifact/installer/version.txt
          body: |
            ## PassWall ${{ steps.parsever.outputs.appver }} for iStoreOS - ${{ inputs.target_arch }}
            
            PassWall(luci-app)版本: ${{ steps.parsever.outputs.appver }}
            上游Release Tag: ${{ steps.fetch.outputs.version }}
            SDK版本: ${{ inputs.sdk_version }}
            OpenSSL标记: ${{ inputs.openssl_tag }}
            构建时间: ${{ steps.date.outputs.date }}
            目标架构: ${{ inputs.target_arch }}
            GitHub Actions运行ID: ${{ github.run_id }}
            构建选项: ${{ inputs.build_option }}
            
            ### 安装方法
            
            1. 下载 `PassWall_${{ steps.parsever.outputs.appver }}_${{ inputs.target_arch }}_all_sdk_${{ inputs.sdk_version }}.run` 到路由器
            2. 执行 `chmod +x PassWall_${{ steps.parsever.outputs.appver }}_${{ inputs.target_arch }}_all_sdk_${{ inputs.sdk_version }}.run && ./PassWall_${{ steps.parsever.outputs.appver }}_${{ inputs.target_arch }}_all_sdk_${{ inputs.sdk_version }}.run`
            3. 完成后，在LuCI界面中访问 服务→PassWall
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}