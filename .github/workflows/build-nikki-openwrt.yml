name: Build Nikki OpenWrt for iStoreOS

# 基于 PassWall 工作流逻辑，适配 nikkinikki-org/OpenWrt-nikki 项目

on:
  workflow_dispatch:
    inputs:
      target_arch:
        description: '目标架构'
        required: true
        default: 'x86_64'
        type: choice
        options:
          - x86_64
          - aarch64_cortex-a53
          - aarch64_generic
      sdk_version:
        description: 'SDK 版本标记（用于文件名和标签）'
        required: true
        default: '22.03.7'
      openssl_tag:
        description: 'OpenSSL 标记（用于标签）'
        required: true
        default: 'libopenssl_1.1'
      build_option:
        description: '构建选项'
        required: true
        default: 'standard'
        type: choice
        options:
          - minimal
          - standard
          - full

permissions:
  contents: write

jobs:
  build:
    name: 构建 Nikki OpenWrt 安装包
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 获取日期
        id: date
        run: echo "date=$(date)" >> "$GITHUB_OUTPUT"

      - name: 准备环境
        run: |
          sudo apt-get update
          sudo apt-get install -y makeself unzip curl jq
          rm -rf artifact/installer
          mkdir -p nikki-ipk artifact/installer staging

      - name: 下载 Nikki OpenWrt 包并解析版本
        id: fetch
        run: |
          set -e
          curl_gh() { curl -fsSL -H "Authorization: Bearer ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" "$@"; }
          # 架构映射
          case "${{ inputs.target_arch }}" in
            x86_64) ARCH_MAP="x86_64" ;;
            aarch64_cortex-a53) ARCH_MAP="aarch64_cortex-a53" ;;
            aarch64_generic) ARCH_MAP="aarch64_generic" ;;
            *) ARCH_MAP="x86_64" ;;
          esac
          echo "ARCH_MAP=$ARCH_MAP" >> "$GITHUB_ENV"

          # 最新 tag
          API_LATEST="https://api.github.com/repos/nikkinikki-org/OpenWrt-nikki/releases/latest"
          LATEST_VERSION=$(curl_gh "$API_LATEST" | jq -r .tag_name || true)
          [ -z "$LATEST_VERSION" ] || [ "$LATEST_VERSION" = "null" ] && LATEST_VERSION="v1.0.0"
          echo "LATEST_VERSION=$LATEST_VERSION" >> "$GITHUB_ENV"
          echo "version=$LATEST_VERSION" >> "$GITHUB_OUTPUT"

          # 下载 nikki 架构特定的 tar.gz 包
          set +e
          URL1="https://github.com/nikkinikki-org/OpenWrt-nikki/releases/download/$LATEST_VERSION/nikki_${ARCH_MAP}-openwrt-24.10.tar.gz"
          URL2="https://github.com/nikkinikki-org/OpenWrt-nikki/releases/download/$LATEST_VERSION/nikki_${ARCH_MAP}-SNAPSHOT.tar.gz"
          URL3="https://github.com/nikkinikki-org/OpenWrt-nikki/releases/download/$LATEST_VERSION/nikki_${ARCH_MAP}.tar.gz"
          echo "尝试下载: $URL1"
          if curl -fL "$URL1" -o nikki-ipk/nikki_packages.tar.gz; then
            DOWNLOAD_FILE="nikki_packages.tar.gz"
          elif curl -fL "$URL2" -o nikki-ipk/nikki_packages.tar.gz; then
            DOWNLOAD_FILE="nikki_packages.tar.gz"
          elif curl -fL "$URL3" -o nikki-ipk/nikki_packages.tar.gz; then
            DOWNLOAD_FILE="nikki_packages.tar.gz"
          else
            DOWNLOAD_FILE=""
          fi
          RC=$?
          set -e
          if [ $RC -ne 0 ] || [ -z "$DOWNLOAD_FILE" ] || [ ! -s "nikki-ipk/$DOWNLOAD_FILE" ]; then
            echo "下载失败: 未找到可用的 Nikki OpenWrt 包"
            echo "尝试的 URL:"
            echo "  $URL1"
            echo "  $URL2" 
            echo "  $URL3"
            exit 1
          fi

          echo "下载成功，解压中..."
          tar -xzf nikki-ipk/$DOWNLOAD_FILE -C nikki-ipk/ 2>/dev/null || tar -xzf nikki-ipk/$DOWNLOAD_FILE -C nikki-ipk/ --strip-components=1
          rm -f nikki-ipk/$DOWNLOAD_FILE

          echo "已解压文件："
          find nikki-ipk -type f -name "*.ipk" | head -20
          echo "目录结构："
          ls -lah nikki-ipk | sed -n '1,20p'

      - name: 校验并定位 luci 顶层包（缺失则多源补齐）
        id: locate
        run: |
          set -e
          curl_gh() { curl -fsSL -H "Authorization: Bearer ${GITHUB_TOKEN}" -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" "$@"; }
          LATEST_VERSION="${LATEST_VERSION:?need version}"

          # 放宽匹配：查找 nikki 相关的 luci 包
          find_app() { 
            # 优先查找 nikki 相关的包
            find nikki-ipk -type f -name '*luci-app-nikki*.ipk' | head -n1 || \
            find nikki-ipk -type f -name '*nikki*.ipk' | head -n1 || \
            find nikki-ipk -type f -name '*luci-app-*.ipk' | head -n1 || true
          }
          find_i18n() { 
            find nikki-ipk -type f -name '*luci-i18n-*-zh-cn*.ipk' | head -n1 || \
            find nikki-ipk -type f -name '*i18n*zh-cn*.ipk' | head -n1 || true
          }

          APP_PKG="$(find_app)"; I18N_PKG="$(find_i18n)"

          fetch_from_release() {
            repo="$1"; tag="$2"
            if [ "$tag" = "latest" ]; then
              json="$(curl_gh "https://api.github.com/repos/$repo/releases/latest" || true)"
            else
              json="$(curl_gh "https://api.github.com/repos/$repo/releases/tags/$tag" || true)"
              [ -z "$json" ] && json="$(curl_gh "https://api.github.com/repos/$repo/releases/latest" || true)"
            fi
            [ -z "$json" ] && return 0
            if [ -z "$APP_PKG" ]; then
              # 放宽正则：任意前缀，任意后缀
              url="$(echo "$json" | jq -r '.assets[] | select(.name|test(".*luci-app.*\\.ipk$")) | .browser_download_url' | head -n1)"
              [ -n "$url" ] && [ "$url" != "null" ] && echo "下载 APP: $url (from $repo/$tag)" && curl -fL "$url" -o "nikki-ipk/$(basename "$url")" && APP_PKG="$(find_app)"
            fi
            if [ -z "$I18N_PKG" ]; then
              # 放宽正则：任意前缀，任意后缀
              url="$(echo "$json" | jq -r '.assets[] | select(.name|test(".*luci-i18n.*zh-cn.*\\.ipk$")) | .browser_download_url' | head -n1)"
              [ -n "$url" ] && [ "$url" != "null" ] && echo "下载 I18N: $url (from $repo/$tag)" && curl -fL "$url" -o "nikki-ipk/$(basename "$url")" && I18N_PKG="$(find_i18n)"
            fi
          }

          # 若缺失则多源补齐
          if [ -z "$APP_PKG" ] || [ -z "$I18N_PKG" ]; then
            fetch_from_release "nikkinikki-org/OpenWrt-nikki" "$LATEST_VERSION"
            fetch_from_release "nikkinikki-org/OpenWrt-nikki" "latest"
          fi

          # 重新定位
          APP_PKG="$(find_app)"; I18N_PKG="$(find_i18n)"

          if [ -z "$APP_PKG" ]; then
            echo "未找到 luci-app 顶层包，尝试查找其他包..."
            # 如果没有找到 luci-app，查找任意 ipk 文件
            APP_PKG="$(find nikki-ipk -type f -name '*.ipk' | head -n1 || true)"
            if [ -z "$APP_PKG" ]; then
              echo "未找到任何 ipk 包"
              find nikki-ipk -maxdepth 2 -type f -print
              exit 1
            fi
          fi
          if [ -z "$I18N_PKG" ]; then
            echo "未找到 zh-cn 语言包，将跳过语言包安装"
            I18N_PKG=""
          fi

          echo "APP_PKG_PATH=$APP_PKG" >> "$GITHUB_ENV"
          echo "I18N_PKG_PATH=$I18N_PKG" >> "$GITHUB_ENV"
          echo "app_path=$APP_PKG" >> "$GITHUB_OUTPUT"
          echo "i18n_path=$I18N_PKG" >> "$GITHUB_OUTPUT"

          echo "定位结果："
          ls -lh "$APP_PKG" ${I18N_PKG:+"$I18N_PKG"}

      - name: 解析 luci-app 版本号（用于命名）
        id: parsever
        run: |
          set -e
          APP_PATH="${APP_PKG_PATH:-${{ steps.locate.outputs.app_path }}}"
          if [ -n "$APP_PATH" ]; then
            BASE="$(basename "$APP_PATH")"
            # 放宽正则：从任意前缀中提取版本号
            APPVER="$(echo "$BASE" | sed -E 's/^.*_([0-9]+\.[0-9]+[^_]*).*\.ipk$/\1/' || true)"
          fi
          if [ -z "${APPVER:-}" ] || [ "$APPVER" = "$BASE" ]; then
            LV="${{ steps.fetch.outputs.version }}"; APPVER="${LV#v}"
          fi
          echo "appver=$APPVER" >> "$GITHUB_OUTPUT"
          echo "APP_VERSION=$APPVER" >> "$GITHUB_ENV"

      - name: 构建 Makeself 安装包（完全对齐样例结构/逻辑）
        run: |
          set -e
          ARCH_MAP="${ARCH_MAP:-${{ inputs.target_arch }}}"
          LATEST_VERSION="${LATEST_VERSION:-${{ steps.fetch.outputs.version }}}"
          APP_VERSION="${APP_VERSION:-${{ steps.parsever.outputs.appver }}}"
          SDK_VERSION="${{ inputs.sdk_version }}"
          OPENSSL_TAG="${{ inputs.openssl_tag }}"
          APP_PKG_PATH="${APP_PKG_PATH:-${{ steps.locate.outputs.app_path }}}"
          I18N_PKG_PATH="${I18N_PKG_PATH:-${{ steps.locate.outputs.i18n_path }}}"

          echo "将打包的顶层包："
          ls -lh "$APP_PKG_PATH" ${I18N_PKG_PATH:+"$I18N_PKG_PATH"}

          STAGING_ROOT="staging"
          STAGING_DIR="$STAGING_ROOT/$ARCH_MAP"
          DEP_DIR="$STAGING_DIR/depends"
          rm -rf "$STAGING_DIR"
          mkdir -p "$DEP_DIR"

          # 复制为固定文件名，避免通配匹配
          APP_BASE="$(basename "$APP_PKG_PATH")"
          cp -f "$APP_PKG_PATH" "$STAGING_DIR/$APP_BASE"
          cp -f "$APP_PKG_PATH" "$STAGING_DIR/luci-app-nikki.ipk"  # 固定名称

          if [ -n "$I18N_PKG_PATH" ]; then
            I18N_BASE="$(basename "$I18N_PKG_PATH")"
            cp -f "$I18N_PKG_PATH" "$STAGING_DIR/$I18N_BASE"
            cp -f "$I18N_PKG_PATH" "$STAGING_DIR/luci-i18n-nikki-zh-cn.ipk"  # 固定名称
          fi

          # 其余 ipk 全部放入 depends
          while IFS= read -r -d '' f; do
            b="$(basename "$f")"
            if [ "$b" != "$APP_BASE" ] && [ -z "$I18N_PKG_PATH" -o "$b" != "$(basename "$I18N_PKG_PATH")" ]; then
              cp -f "$f" "$DEP_DIR/$b"
            fi
          done < <(find nikki-ipk -type f -name '*.ipk' -print0)

          echo "打包目录预览："
          find "$STAGING_DIR" -maxdepth 2 -type f -print | sed -n '1,200p'

          # 生成安装脚本（使用固定文件名，不再通配）
          cat > "$STAGING_DIR/install.sh" <<'EOF'
          #!/bin/sh
          set -e

          # 检查并安装 Nikki OpenWrt 必需依赖
          check_nikki_deps() {
            echo "检查 Nikki OpenWrt 必需依赖..."
            
            # 基础依赖
            local base_deps="luci-compat luci-lib-jsonc libuci-lua"
            
            for dep in $base_deps; do
              if ! opkg list-installed | grep -q "^$dep "; then
                echo "安装缺失依赖: $dep"
                opkg install "$dep" 2>/dev/null || echo "警告: 无法安装 $dep，可能需要手动处理"
              fi
            done
          }

          # 温和地刷新 LuCI 缓存（不重启服务，避免丢失登录状态）
          refresh_luci() {
            # 清理缓存文件
            rm -f /tmp/luci-indexcache 2>/dev/null || true
            rm -rf /tmp/luci-modulecache/* 2>/dev/null || true
            
            # 优先使用 luci-reload（如果可用）
            if command -v luci-reload >/dev/null 2>&1; then
              echo "使用 luci-reload 刷新 LuCI..."
              luci-reload 2>/dev/null || true
            else
              # 使用 Lua 直接重建索引（兼容不同版本函数名）
              if command -v lua >/dev/null 2>&1; then
                echo "使用 Lua 重建 LuCI 索引..."
                lua -e 'local ok,d=pcall(require,"luci.dispatcher"); if ok and d then if d.rebuild_index then d.rebuild_index() elseif d.createindex then d.createindex() end end' 2>/dev/null || true
              fi
              
              # 温和地重载 HTTP 服务（不重启）
              if [ -x /etc/init.d/uhttpd ]; then
                echo "重载 uhttpd..."
                /etc/init.d/uhttpd reload 2>/dev/null || true
              fi
              if [ -x /etc/init.d/nginx ]; then
                echo "重载 nginx..."
                /etc/init.d/nginx reload 2>/dev/null || true
              fi
            fi
            
            # 确保文件系统同步
            sync
          }

          # 使用固定文件名，不再通配
          APP_PKG="luci-app-nikki.ipk"
          I18N_PKG="luci-i18n-nikki-zh-cn.ipk"

          if [ ! -f "$APP_PKG" ]; then
            echo "错误: 缺少 $APP_PKG"
            ls -l
            exit 1
          fi

          # 安装前轻度刷新
          refresh_luci

          if ! opkg update; then
            echo "更新软件源列表错误，请检查路由器网络以及软件源。"
            exit 1
          fi

          # 安装基础依赖（容错）
          echo "安装基础依赖..."
          opkg install luci-compat luci-lib-jsonc libuci-lua 2>/dev/null || true

          # 检查并安装 Nikki OpenWrt 必需依赖
          check_nikki_deps

          # 安装 depends 下的 ipk（若存在）
          if [ -d depends ] && ls depends/*.ipk >/dev/null 2>&1; then
            echo "安装依赖包..."
            opkg install depends/*.ipk || true
          fi

          # 始终强制重装，避免版本判断带来的不确定性
          echo "安装 Nikki OpenWrt 主程序..."
          opkg install "$APP_PKG" --force-reinstall || exit 1

          # 安装中文语言包（仅本地文件）
          if [ -f "$I18N_PKG" ]; then
            echo "安装中文语言包: $I18N_PKG"
            opkg install "$I18N_PKG" || true
          else
            echo "未发现本地中文语言包，跳过安装"
          fi

          # 启用并启动服务（如果存在）
          for service in nikki nikki-openwrt; do
            if [ -x /etc/init.d/$service ]; then
              echo "启用 $service 服务..."
              /etc/init.d/$service enable 2>/dev/null || true
              /etc/init.d/$service start 2>/dev/null || true
            fi
          done
          
          # 重载防火墙（不重启）
          if [ -x /etc/init.d/firewall ]; then
            echo "重载防火墙规则..."
            /etc/init.d/firewall reload 2>/dev/null || true
          fi

          # 安装后轻度刷新
          refresh_luci

          # 验证安装结果
          if [ -f /usr/lib/lua/luci/controller/nikki.lua ] || \
             ls /usr/lib/lua/luci/controller/nikki/*.lua >/dev/null 2>&1 || \
             ls /usr/lib/lua/luci/controller/*nikki*.lua >/dev/null 2>&1 || \
             find /usr/lib/lua/luci -name "*nikki*" -type f >/dev/null 2>&1; then
            echo "✓ 安装完成！请在 LuCI 界面查看相关菜单。"
            echo "  如果菜单未显示，请刷新浏览器或重新登录 LuCI。"
            exit 0
          else
            echo "! 警告：未检测到控制器文件，可能需刷新浏览器或重新登录 LuCI。"
            echo "  已安装的包："
            opkg list-installed | grep -i nikki || true
            exit 0
          fi
          EOF
          chmod +x "$STAGING_DIR/install.sh"

          OUTPUT="NikkiOpenWrt_${APP_VERSION}_${ARCH_MAP}_all_sdk_${SDK_VERSION}.run"
          LABEL="NikkiOpenWrt_${APP_VERSION}_with_sdk_${SDK_VERSION}_${OPENSSL_TAG}"
          makeself --gzip --nox11 "$STAGING_DIR" "$OUTPUT" "$LABEL" ./install.sh

          echo "Nikki OpenWrt版本: $APP_VERSION" > version.txt
          echo "上游Release Tag: $LATEST_VERSION" >> version.txt
          echo "SDK版本: $SDK_VERSION" >> version.txt
          echo "OpenSSL标记: $OPENSSL_TAG" >> version.txt
          echo "构建时间: ${{ steps.date.outputs.date }}" >> version.txt
          echo "目标架构: ${{ inputs.target_arch }}" >> version.txt
          echo "GitHub Actions运行ID: ${{ github.run_id }}" >> version.txt
          echo "构建选项: ${{ inputs.build_option }}" >> version.txt

          rm -rf artifact/installer/*
          mv -f "$OUTPUT" artifact/installer/
          mv -f version.txt artifact/installer/
          echo "构建产物："
          ls -lh artifact/installer/

      - name: 上传安装程序
        uses: actions/upload-artifact@v4
        with:
          name: NikkiOpenWrt_${{ steps.parsever.outputs.appver }}_${{ inputs.target_arch }}_all_sdk_${{ inputs.sdk_version }}
          path: ./artifact/installer/

      - name: 创建发布
        uses: softprops/action-gh-release@v1
        with:
          tag_name: nikki-openwrt-${{ inputs.target_arch }}-${{ steps.parsever.outputs.appver }}-${{ github.run_id }}
          name: Nikki OpenWrt ${{ steps.parsever.outputs.appver }} for iStoreOS (${{ inputs.target_arch }})
          files: |
            artifact/installer/NikkiOpenWrt_${{ steps.parsever.outputs.appver }}_${{ inputs.target_arch }}_all_sdk_${{ inputs.sdk_version }}.run
            artifact/installer/version.txt
          body: |
            ## Nikki OpenWrt ${{ steps.parsever.outputs.appver }} for iStoreOS - ${{ inputs.target_arch }}
            
            Nikki OpenWrt版本: ${{ steps.parsever.outputs.appver }}
            上游Release Tag: ${{ steps.fetch.outputs.version }}
            SDK版本: ${{ inputs.sdk_version }}
            OpenSSL标记: ${{ inputs.openssl_tag }}
            构建时间: ${{ steps.date.outputs.date }}
            目标架构: ${{ inputs.target_arch }}
            GitHub Actions运行ID: ${{ github.run_id }}
            构建选项: ${{ inputs.build_option }}
            
            ### 安装方法
            
            1. 下载 `NikkiOpenWrt_${{ steps.parsever.outputs.appver }}_${{ inputs.target_arch }}_all_sdk_${{ inputs.sdk_version }}.run` 到路由器
            2. 执行 `chmod +x NikkiOpenWrt_${{ steps.parsever.outputs.appver }}_${{ inputs.target_arch }}_all_sdk_${{ inputs.sdk_version }}.run && ./NikkiOpenWrt_${{ steps.parsever.outputs.appver }}_${{ inputs.target_arch }}_all_sdk_${{ inputs.sdk_version }}.run`
            3. 完成后，在LuCI界面中查看相关菜单
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}